from tasks.base import BaseTask  # Assuming BaseTask is in tasks.base
from pydantic import BaseModel, Field
from typing import List, Optional
from tools.quiz_generation_tool import QuizGenerationTool


# Assuming you have a tool needed by this task, import it here
# from tools.your_quiz_tool import YourQuizTool

class QuizOutputSchema(BaseModel):
    topic: str = Field(..., description="Topic of the quiz based on the lesson")
    grade_level: str = Field(..., description="Target grade level for the quiz")
    questions: List[dict] = Field(
        ...,
        description="List of question dictionaries each containing question text, options, correct answer, and explanation"
    )
    format_type: str = Field(..., description="Format of quiz questions, e.e., MCQ, Fill-in-the-blank, Match-the-following")
    total_marks: int = Field(..., description="Total marks for the quiz")
    dialect_adapted: bool = Field(..., description="Indicates if the questions are adapted for regional dialect")

class QuizTask(BaseTask): # Inherit from BaseTask
    name = "Generate Quiz from Lesson"
    description = (
        """Accept lesson content and grade level.
Generate 5â€“10 questions covering core concepts.
Ensure question formats match the specified format_type (MCQ, Fill-in-the-blank, Match-the-following).
Use age-appropriate and dialect-adapted language.
Include explanations for each answer.
Maintain alignment with curriculum standards.
Avoid repetition and trivial questions.
Output JSON following the QuizOutputSchema.
Ensure questions are auto-gradable."""
    )
    expected_output = QuizOutputSchema
    output_json = True
    context_injection = True
    verbose = True
    output_file = "outputs/quiz_output_{timestamp}.json"
    guardrails={
        "retry_on_fail": 2,
        "fallback_response": {
            "topic": "Default Topic",
            "grade_level": "Unknown",
            "questions": [],
            "format_type": "MCQ",
            "total_marks": 0,
            "dialect_adapted": False
        }
    }
    metadata={
        "agent": "QuizAgent",
        "access": "teacher_and_student",
        "downstream": ["CoursePlannerAgent", "GamificationAgent"],
        "triggers": ["on_lesson_completion"]}


    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.quiz_tool = QuizGenerationTool() # Instantiate the tool


    async def run(self, inputs: dict): # Define async run method
        """
        Asynchronously runs the quiz generation task using the QuizGenerationTool.

        Args:
            inputs (dict): Should contain necessary data like lesson content, grade level, dialect.

        Returns:
            dict: Dictionary conforming to QuizOutputSchema, generated by the tool.
        """
        try:
            # Call the run method of the QuizGenerationTool instance
            # Note: The tool's run method is currently synchronous, so no await needed here
            result = self.quiz_tool.run(inputs)
            return result
        except Exception as e:
            # Return fallback response on error
            return self.guardrails.get("fallback_response", {
                "topic": inputs.get("topic", "Default Topic"),
                "grade_level": inputs.get("grade_level", "Unknown"),
                "questions": [],
                "format_type": "MCQ",
                "total_marks": 0,
                "dialect_adapted": False,
                "error_details": str(e) # Add error details to fallback
            })


# Instantiate the task
quiz_task = QuizTask(name=QuizTask.name, description=QuizTask.description) # Instantiate the class
